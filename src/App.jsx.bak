import { Fragment, useEffect, useMemo, useState } from "react"
import { getSmallPoster } from "./utils/poster.js"
import { sortItems, getGroupKey } from "./utils/sorting.js"
import { fetchPoster } from "./api/tmdb.js"
import { loadFromSheets as loadFromSheetsAPI, saveToSheets as saveToSheetsAPI } from "./api/sheets.js"
import ItemModal from "./components/ItemModal.jsx"
import AddModal from "./components/AddModal.jsx"
import EditModal from "./components/EditModal.jsx"
import FixPosterModal from "./components/FixPosterModal.jsx"

const App = () => {
	const [tab, setTab] = useState("films")
	const [films, setFilms] = useState(() => {
		const cached = localStorage.getItem("cine_films_cache")
		return cached ? JSON.parse(cached) : []
	})
	const [series, setSeries] = useState(() => {
		const cached = localStorage.getItem("cine_series_cache")
		return cached ? JSON.parse(cached) : []
	})
	const [books, setBooks] = useState(() => {
		const cached = localStorage.getItem("cine_books_cache")
		return cached ? JSON.parse(cached) : []
	})
	const [comics, setComics] = useState(() => {
		const cached = localStorage.getItem("cine_comics_cache")
		return cached ? JSON.parse(cached) : []
	})
	const [search, setSearch] = useState("")
	const [filter, setFilter] = useState("all")
	const [genre, setGenre] = useState("")
	const [selected, setSelected] = useState(null)
	const [view, setView] = useState("grid")
	const [cardSize, setCardSize] = useState(120)
	const [showAdd, setShowAdd] = useState(false)
	const [showFix, setShowFix] = useState(false)
	const [loading, setLoading] = useState(false)
	const [syncing, setSyncing] = useState(false)
	const [lastSync, setLastSync] = useState(null)

	const items =
		tab === "films"
			? films
			: tab === "series"
				? series
				: tab === "books"
					? books
					: comics
	const setItems =
		tab === "films"
			? setFilms
			: tab === "series"
				? setSeries
				: tab === "books"
					? setBooks
					: setComics

	const [posterProgress, setPosterProgress] = useState("")

	// Load from Google Sheets on mount
	useEffect(() => {
		const cached = localStorage.getItem("cine_films_cache")
		if (!cached) setLoading(true)
		loadFromSheets()
	}, [])

	// Save to cache whenever data changes
	useEffect(() => {
		if (films.length > 0) {
			localStorage.setItem("cine_films_cache", JSON.stringify(films))
		}
	}, [films])

	useEffect(() => {
		if (series.length > 0) {
			localStorage.setItem("cine_series_cache", JSON.stringify(series))
		}
	}, [series])

	useEffect(() => {
		if (books.length > 0) {
			localStorage.setItem("cine_books_cache", JSON.stringify(books))
		}
	}, [books])

	useEffect(() => {
		if (comics.length > 0) {
			localStorage.setItem("cine_comics_cache", JSON.stringify(comics))
		}
	}, [comics])

	// Fetch missing posters after loading
	const fetchMissingPosters = async (filmsList) => {
		const needPoster = filmsList.filter((f) => !f.poster)
		if (needPoster.length === 0) return filmsList

		setPosterProgress(`0/${needPoster.length}`)
		const updated = [...filmsList]
		let count = 0

		for (const film of needPoster) {
			count++
			setPosterProgress(`${count}/${needPoster.length}`)

			const poster = await fetchPoster(film.title, film.year, "movie")
			if (poster) {
				const idx = updated.findIndex((f) => f.id === film.id)
				if (idx !== -1) {
					updated[idx] = { ...updated[idx], poster }
				}
			}
			await new Promise((r) => setTimeout(r, 200))
		}

		setPosterProgress("")
		return updated
	}

	const loadFromSheets = async () => {
		setSyncing(true)
		try {
			const { loadedFilms, loadedSeries, loadedBooks, loadedComics } =
				await loadFromSheetsAPI()

			// Mettre √† jour imm√©diatement avec les donn√©es du serveur
			setFilms(loadedFilms)
			setSeries(loadedSeries)
			setBooks(loadedBooks)
			setComics(loadedComics)
			setLoading(false)
			setSyncing(false)
			setLastSync(new Date())

			// Check if we need to fetch posters (en arri√®re-plan)
			const missingPosters = loadedFilms.filter((f) => !f.poster).length

			if (missingPosters > 0) {
				const updatedFilms = await fetchMissingPosters(loadedFilms)
				setFilms(updatedFilms)
				// Save updated films with posters to Sheets
				await saveToSheetsAPI(updatedFilms, loadedSeries, loadedBooks, loadedComics)
			}
		} catch (e) {
			console.error("Erreur chargement:", e)
			setSyncing(false)
			setLoading(false)
		}
	}

	const saveToSheets = async (newFilms, newSeries, newBooks, newComics) => {
		setSyncing(true)
		try {
			await saveToSheetsAPI(
				newFilms !== undefined ? newFilms : films,
				newSeries !== undefined ? newSeries : series,
				newBooks !== undefined ? newBooks : books,
				newComics !== undefined ? newComics : comics,
			)
			setLastSync(new Date())

			// Also save to localStorage as backup
			localStorage.setItem("cine_films", JSON.stringify(newFilms || films))
			localStorage.setItem("cine_series", JSON.stringify(newSeries || series))
		} catch (e) {
			console.error("Erreur sauvegarde:", e)
		}
		setSyncing(false)
	}

	const [sort, setSort] = useState("year-desc")
	const [showSeparators, setShowSeparators] = useState(true)
	const [showEdit, setShowEdit] = useState(false)

	const genres = [
		...new Set(
			items.flatMap((f) =>
				f.genre ? f.genre.split(",").map((g) => g.trim()) : [],
			),
		),
	].sort()

	const filtered = sortItems(
		items.filter((f) => {
			if (
				search &&
				!f.title?.toLowerCase().includes(search.toLowerCase()) &&
				!f.director?.toLowerCase().includes(search.toLowerCase()) &&
				!f.author?.toLowerCase().includes(search.toLowerCase())
			)
				return false
			if (filter === "watched" && !f.watched) return false
			if (filter === "unwatched" && f.watched) return false
			if (genre && !f.genre?.toLowerCase().includes(genre.toLowerCase()))
				return false
			return true
		}),
		sort,
	)

	const groupedItems = useMemo(() => {
		if (sort === "added") return [{ key: null, items: filtered }]

		const groups = []
		let currentKey = null

		filtered.forEach((item) => {
			const key = getGroupKey(item, sort, tab)
			if (key !== currentKey) {
				groups.push({ key, items: [item] })
				currentKey = key
			} else {
				groups[groups.length - 1].items.push(item)
			}
		})

		return groups
	}, [filtered, sort, tab])

	const stats = {
		total: items.length,
		watched: items.filter((f) => f.watched).length,
	}

	const saveAll = (newFilms, newSeries, newBooks, newComics) => {
		saveToSheets(
			newFilms !== undefined ? newFilms : films,
			newSeries !== undefined ? newSeries : series,
			newBooks !== undefined ? newBooks : books,
			newComics !== undefined ? newComics : comics,
		)
	}

	const toggleWatch = (id, e) => {
		if (e) e.stopPropagation()
		const newItems = items.map((f) =>
			f.id === id ? { ...f, watched: !f.watched } : f,
		)
		setItems(newItems)
		if (selected?.id === id)
			setSelected({ ...selected, watched: !selected.watched })

		// Save to sheets
		if (tab === "films") saveAll(newItems, undefined, undefined, undefined)
		else if (tab === "series")
			saveAll(undefined, newItems, undefined, undefined)
		else if (tab === "books") saveAll(undefined, undefined, newItems, undefined)
		else saveAll(undefined, undefined, undefined, newItems)
	}

	const addItem = (item) => {
		const newItems = [item, ...items]
		setItems(newItems)

		if (tab === "films") saveAll(newItems, undefined, undefined, undefined)
		else if (tab === "series")
			saveAll(undefined, newItems, undefined, undefined)
		else if (tab === "books") saveAll(undefined, undefined, newItems, undefined)
		else saveAll(undefined, undefined, undefined, newItems)
	}

	const deleteItem = (id) => {
		const newItems = items.filter((f) => f.id !== id)
		setItems(newItems)
		setSelected(null)

		if (tab === "films") saveAll(newItems, undefined, undefined, undefined)
		else if (tab === "series")
			saveAll(undefined, newItems, undefined, undefined)
		else if (tab === "books") saveAll(undefined, undefined, newItems, undefined)
		else saveAll(undefined, undefined, undefined, newItems)
	}

	const updatePoster = (id, updates) => {
		// updates peut √™tre {poster, title, year} ou juste {poster}
		const newItems = items.map((f) => {
			if (f.id === id) {
				return {
					...f,
					poster: updates.poster || f.poster,
					title: updates.title || f.title,
					year: updates.year || f.year,
				}
			}
			return f
		})
		setItems(newItems)
		if (selected?.id === id) {
			setSelected({
				...selected,
				poster: updates.poster || selected.poster,
				title: updates.title || selected.title,
				year: updates.year || selected.year,
			})
		}
		setShowFix(false)

		if (tab === "films") saveAll(newItems, undefined, undefined, undefined)
		else if (tab === "series")
			saveAll(undefined, newItems, undefined, undefined)
		else if (tab === "books") saveAll(undefined, undefined, newItems, undefined)
		else saveAll(undefined, undefined, undefined, newItems)
	}

	const updateItem = (id, updates) => {
		const newItems = items.map((f) => (f.id === id ? { ...f, ...updates } : f))
		setItems(newItems)
		if (selected?.id === id) setSelected({ ...selected, ...updates })
		setShowEdit(false)

		if (tab === "films") saveAll(newItems, undefined, undefined, undefined)
		else if (tab === "series")
			saveAll(undefined, newItems, undefined, undefined)
		else if (tab === "books") saveAll(undefined, undefined, newItems, undefined)
		else saveAll(undefined, undefined, undefined, newItems)
	}

	if (loading && films.length === 0) {
		return (
			<div className="loading-screen">
				<div className="loading-spinner"></div>
				<div>Chargement de ta cin√©math√®que...</div>
			</div>
		)
	}

	return (
		<div>
			<header className="header">
				<div className="header-top">
					<div className="logo">
						ma <span>collection</span>
					</div>
					<div className="header-right">
						<div className="stats">
							<b>{stats.total}</b> {tab} ¬∑ <b>{stats.watched}</b>{" "}
							{tab === "books" || tab === "comics"
								? stats.watched > 1
									? "lus"
									: "lu"
								: stats.watched > 1
									? "vus"
									: "vu"}
							{syncing && <span className="sync-icon"> ‚ü≥</span>}
						</div>
						<button className="add-btn" onClick={() => setShowAdd(true)}>
							+ Ajouter
						</button>
					</div>
				</div>

				{posterProgress && (
					<div className="poster-progress">
						T√©l√©chargement des affiches... {posterProgress}
					</div>
				)}

				<div className="tabs">
					<button
						className={`tab ${tab === "films" ? "active" : ""}`}
						onClick={() => {
							setTab("films")
							setGenre("")
						}}
					>
						Films <span className="tab-count">{films.length}</span>
					</button>
					<button
						className={`tab ${tab === "series" ? "active" : ""}`}
						onClick={() => {
							setTab("series")
							setGenre("")
						}}
					>
						S√©ries <span className="tab-count">{series.length}</span>
					</button>
					<button
						className={`tab ${tab === "books" ? "active" : ""}`}
						onClick={() => {
							setTab("books")
							setGenre("")
						}}
					>
						Livres <span className="tab-count">{books.length}</span>
					</button>
					<button
						className={`tab ${tab === "comics" ? "active" : ""}`}
						onClick={() => {
							setTab("comics")
							setGenre("")
						}}
					>
						BD <span className="tab-count">{comics.length}</span>
					</button>
				</div>

				<div className="controls">
					<input
						className="search-box"
						placeholder="Rechercher..."
						value={search}
						onChange={(e) => setSearch(e.target.value)}
					/>
					<div className="filter-divider"></div>
					<button
						className={`filter-btn ${filter === "all" ? "active" : ""}`}
						onClick={() => setFilter("all")}
					>
						Tous
					</button>
					<button
						className={`filter-btn ${filter === "unwatched" ? "active" : ""}`}
						onClick={() => setFilter("unwatched")}
					>
						{tab === "books" || tab === "comics" ? "√Ä lire" : "√Ä voir"}
					</button>
					<button
						className={`filter-btn ${filter === "watched" ? "active" : ""}`}
						onClick={() => setFilter("watched")}
					>
						{tab === "books" || tab === "comics" ? "Lus" : "Vus"}
					</button>
					<div className="filter-divider"></div>
					<select value={genre} onChange={(e) => setGenre(e.target.value)}>
						<option value="">Genre</option>
						{genres.map((g) => (
							<option key={g} value={g}>
								{g}
							</option>
						))}
					</select>
					<select
						value={sort}
						onChange={(e) => setSort(e.target.value)}
						className="sort-select"
					>
						<option value="year-desc">Ann√©e ‚Üì</option>
						<option value="year-asc">Ann√©e ‚Üë</option>
						<option value="alpha-asc">A ‚Üí Z</option>
						<option value="alpha-desc">Z ‚Üí A</option>
						<option value="director">
							{tab === "films"
								? "R√©alisateur"
								: tab === "series"
									? "Cr√©ateur"
									: "Auteur"}
						</option>
						<option value="added">R√©cents</option>
						<option value="unwatched">
							{tab === "books" || tab === "comics" ? "Non lus" : "Non vus"}
						</option>
					</select>
					<div className="view-controls">
						<button
							className={`view-btn ${view === "grid" ? "active" : ""}`}
							onClick={() => setView("grid")}
						>
							‚ñ¶
						</button>
						<button
							className={`view-btn ${view === "list" ? "active" : ""}`}
							onClick={() => setView("list")}
						>
							‚ò∞
						</button>
						<button
							className={`view-btn ${showSeparators ? "active" : ""}`}
							onClick={() => setShowSeparators(!showSeparators)}
							title="S√©parateurs"
						>
							‚Äï
						</button>
						{view === "grid" && (
							<input
								type="range"
								className="size-slider"
								min="80"
								max="160"
								value={cardSize}
								onChange={(e) => setCardSize(Number(e.target.value))}
							/>
						)}
					</div>
				</div>
			</header>

			<main className="main">
				<div className="count">
					{filtered.length} {tab}
				</div>
				{filtered.length > 0 ? (
					view === "grid" ? (
						<div className={showSeparators ? "grid-container" : ""}>
							{showSeparators ? (
								groupedItems.map((group, gi) => (
									<Fragment key={gi}>
										{group.key && (
											<div className="group-separator">{group.key}</div>
										)}
										<div
											className="grid"
											style={{ "--card-size": cardSize + "px" }}
										>
											{group.items.map((f) => (
												<div
													key={f.id}
													className={`card ${f.watched ? "is-watched" : "is-unwatched"}`}
													onClick={() => setSelected(f)}
												>
													{f.poster ? (
														<>
															<img
																className="card-img"
																src={getSmallPoster(f.poster)}
																alt={f.title}
																loading="lazy"
															/>
															<div className="card-info">
																<div className="card-title">{f.title}</div>
																<div className="card-year">{f.year}</div>
															</div>
														</>
													) : (
														<div className="card-noimg">
															<div className="card-title">{f.title}</div>
															<div className="card-year">{f.year}</div>
														</div>
													)}
													<div
														className={`watch-btn ${f.watched ? "watched" : ""}`}
														onClick={(e) => toggleWatch(f.id, e)}
													>
														‚úì
													</div>
												</div>
											))}
										</div>
									</Fragment>
								))
							) : (
								<div
									className="grid"
									style={{ "--card-size": cardSize + "px" }}
								>
									{filtered.map((f) => (
										<div
											key={f.id}
											className={`card ${f.watched ? "is-watched" : "is-unwatched"}`}
											onClick={() => setSelected(f)}
										>
											{f.poster ? (
												<>
													<img
														className="card-img"
														src={getSmallPoster(f.poster)}
														alt={f.title}
														loading="lazy"
													/>
													<div className="card-info">
														<div className="card-title">{f.title}</div>
														<div className="card-year">{f.year}</div>
													</div>
												</>
											) : (
												<div className="card-noimg">
													<div className="card-title">{f.title}</div>
													<div className="card-year">{f.year}</div>
												</div>
											)}
											<div
												className={`watch-btn ${f.watched ? "watched" : ""}`}
												onClick={(e) => toggleWatch(f.id, e)}
											>
												‚úì
											</div>
										</div>
									))}
								</div>
							)}
						</div>
					) : (
						<div className={showSeparators ? "list-container" : ""}>
							{showSeparators ? (
								groupedItems.map((group, gi) => (
									<Fragment key={gi}>
										{group.key && (
											<div className="group-separator">{group.key}</div>
										)}
										<div className="list">
											{group.items.map((f) => (
												<div
													key={f.id}
													className={`list-item ${f.watched ? "is-watched" : "is-unwatched"}`}
													onClick={() => setSelected(f)}
												>
													{f.poster ? (
														<img
															className="list-poster"
															src={getSmallPoster(f.poster)}
															alt=""
															loading="lazy"
														/>
													) : (
														<div className="list-poster-empty">?</div>
													)}
													<div className="list-info">
														<div className="list-title">{f.title}</div>
														<div className="list-meta">
															{f.director || f.creator || f.author} ¬∑ {f.year}
														</div>
													</div>
													<div
														className={`watch-btn ${f.watched ? "watched" : ""}`}
														onClick={(e) => toggleWatch(f.id, e)}
													>
														‚úì
													</div>
												</div>
											))}
										</div>
									</Fragment>
								))
							) : (
								<div className="list">
									{filtered.map((f) => (
										<div
											key={f.id}
											className={`list-item ${f.watched ? "is-watched" : "is-unwatched"}`}
											onClick={() => setSelected(f)}
										>
											{f.poster ? (
												<img
													className="list-poster"
													src={getSmallPoster(f.poster)}
													alt=""
													loading="lazy"
												/>
											) : (
												<div className="list-poster-empty">?</div>
											)}
											<div className="list-info">
												<div className="list-title">{f.title}</div>
												<div className="list-meta">
													{f.director || f.creator || f.author} ¬∑ {f.year}
												</div>
											</div>
											<div
												className={`watch-btn ${f.watched ? "watched" : ""}`}
												onClick={(e) => toggleWatch(f.id, e)}
											>
												‚úì
											</div>
										</div>
									))}
								</div>
							)}
						</div>
					)
				) : (
					<div className="empty">
						{items.length === 0
							? `Aucun ${tab === "films" ? "film" : tab === "series" ? "s√©rie" : tab === "books" ? "livre" : "BD"} ajout√©. Clique sur "+ Ajouter" !`
							: "Aucun r√©sultat"}
					</div>
				)}
			</main>

			{selected && (
				<ItemModal
					item={selected}
					tab={tab}
					onClose={() => setSelected(null)}
					onToggleWatch={(id) => toggleWatch(id)}
					onEdit={() => setShowEdit(true)}
					onFix={() => setShowFix(true)}
					onDelete={deleteItem}
					items={items}
					onAdd={addItem}
				/>
			)}

			{showAdd && (
				<AddModal
					type={tab}
					onClose={() => setShowAdd(false)}
					onAdd={addItem}
				/>
			)}
			{showFix && selected && (
				<FixPosterModal
					item={selected}
					type={tab}
					onClose={() => setShowFix(false)}
					onSelect={updatePoster}
				/>
			)}
			{showEdit && selected && (
				<EditModal
					item={selected}
					type={tab}
					onClose={() => setShowEdit(false)}
					onSave={updateItem}
				/>
			)}
		</div>
	)
}

// Fix Poster Modal
const FixPosterModal = ({ item, type, onClose, onSelect }) => {
	const [query, setQuery] = useState(item.title)
	const [year, setYear] = useState(item.year || "")
	const [results, setResults] = useState([])
	const [searching, setSearching] = useState(false)
	const [source, setSource] = useState("tmdb")
	const [manualUrl, setManualUrl] = useState("")
	const [showManual, setShowManual] = useState(false)

	const doSearch = async () => {
		if (!query) return
		setSearching(true)
		setResults([])

		if (source === "tmdb") {
			const endpoint = type === "films" ? "search/movie" : "search/tv"
			const yearParam = year ? `&year=${year}` : ""
			try {
				const res = await fetch(
					`https://api.themoviedb.org/3/${endpoint}?api_key=${TMDB_KEY}&query=${encodeURIComponent(query)}${yearParam}`,
				)
				const data = await res.json()
				setResults(
					data.results?.slice(0, 12).map((m) => ({
						id: m.id,
						title: m.title || m.name,
						year: (m.release_date || m.first_air_date)?.split("-")[0],
						poster: m.poster_path ? TMDB_IMG_SM + m.poster_path : null,
						source: "TMDB",
					})) || [],
				)
			} catch (e) {}
		} else {
			const omdbType = type === "films" ? "movie" : "series"
			const yearParam = year ? `&y=${year}` : ""
			try {
				const res = await fetch(
					`https://www.omdbapi.com/?apikey=${OMDB_KEY}&s=${encodeURIComponent(query)}&type=${omdbType}${yearParam}`,
				)
				const data = await res.json()
				if (data.Search) {
					setResults(
						data.Search.slice(0, 12).map((m) => ({
							id: m.imdbID,
							title: m.Title,
							year: m.Year,
							poster: m.Poster !== "N/A" ? m.Poster : null,
							source: "OMDb",
						})),
					)
				}
			} catch (e) {}
		}
		setSearching(false)
	}

	useEffect(() => {
		doSearch()
	}, [source])

	const applyManualUrl = () => {
		if (manualUrl && manualUrl.startsWith("http")) {
			onSelect(item.id, { poster: manualUrl })
		}
	}

	const selectResult = (r) => {
		if (!r.poster) return
		onSelect(item.id, {
			poster: r.poster,
			title: r.title,
			year: parseInt(r.year) || item.year,
		})
	}

	return (
		<div className="modal-bg" onClick={onClose}>
			<div className="modal fix-modal" onClick={(e) => e.stopPropagation()}>
				<div className="modal-head">
					<div className="modal-title">Corriger le film</div>
					<button className="modal-close" onClick={onClose}>
						√ó
					</button>
				</div>
				<div className="modal-body">
					<div className="fix-search">
						<input
							type="text"
							className="search-box"
							value={query}
							onChange={(e) => setQuery(e.target.value)}
							onKeyDown={(e) => e.key === "Enter" && doSearch()}
							placeholder="Titre"
							style={{ flex: 1 }}
						/>
						<input
							type="number"
							className="search-box year-input"
							value={year}
							onChange={(e) => setYear(e.target.value)}
							placeholder="Ann√©e"
						/>
						<button className="btn btn-primary" onClick={doSearch}>
							üîç
						</button>
					</div>

					<div className="source-toggle">
						<button
							className={`source-btn ${source === "tmdb" ? "active" : ""}`}
							onClick={() => setSource("tmdb")}
						>
							TMDB
						</button>
						<button
							className={`source-btn ${source === "omdb" ? "active" : ""}`}
							onClick={() => setSource("omdb")}
						>
							OMDb/IMDb
						</button>
					</div>

					{searching && <div className="searching">Recherche...</div>}

					<div className="fix-results">
						{results.map((r) => (
							<div
								key={r.id}
								className={`fix-result ${!r.poster ? "no-poster" : ""}`}
								onClick={() => selectResult(r)}
							>
								{r.poster ? (
									<img src={r.poster} alt="" />
								) : (
									<div className="fix-no-poster">Pas d'affiche</div>
								)}
								<div className="fix-result-info">
									<div className="fix-result-title">{r.title}</div>
									<div className="fix-result-year">
										{r.year} ¬∑ {r.source}
									</div>
								</div>
							</div>
						))}
					</div>

					{results.length === 0 && !searching && (
						<div className="empty-small">
							Aucun r√©sultat. Essayez le titre original.
						</div>
					)}

					<div className="manual-section">
						<button
							className="link-btn"
							onClick={() => setShowManual(!showManual)}
						>
							{showManual ? "‚ñº Masquer" : "‚ñ∂ Coller une URL"}
						</button>
						{showManual && (
							<div className="manual-url">
								<input
									type="text"
									className="search-box"
									value={manualUrl}
									onChange={(e) => setManualUrl(e.target.value)}
									placeholder="https://..."
									style={{ flex: 1 }}
								/>
								<button className="btn btn-primary" onClick={applyManualUrl}>
									OK
								</button>
							</div>
						)}
					</div>
				</div>
			</div>
		</div>
	)
}

// Add Modal
const AddModal = ({ type, onClose, onAdd }) => {
	const [query, setQuery] = useState("")
	const [results, setResults] = useState([])
	const [searching, setSearching] = useState(false)
	const [form, setForm] = useState({
		title: "",
		director: "",
		creator: "",
		author: "",
		year: "",
		genre: "",
		source: "",
		watched: false,
		poster: "",
		seasons: "",
	})
	const [mode, setMode] = useState("search")
	const timeoutRef = useRef(null)

	const isFilm = type === "films"
	const isSeries = type === "series"
	const isBook = type === "books"
	const isComic = type === "comics"
	const isMedia = isFilm || isSeries

	useEffect(() => {
		if (timeoutRef.current) clearTimeout(timeoutRef.current)
		if (!query || query.length < 2) {
			setResults([])
			return
		}

		timeoutRef.current = setTimeout(async () => {
			setSearching(true)
			try {
				if (isMedia) {
					const endpoint = isFilm ? "search/movie" : "search/tv"
					const res = await fetch(
						`https://api.themoviedb.org/3/${endpoint}?api_key=${TMDB_KEY}&query=${encodeURIComponent(query)}&language=fr-FR`,
					)
					const data = await res.json()
					setResults(data.results?.slice(0, 8) || [])
				} else {
					// Google Books API pour livres et BD
					const res = await fetch(
						`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(query)}&maxResults=8&langRestrict=fr`,
					)
					const data = await res.json()
					setResults(
						data.items?.map((item) => ({
							id: item.id,
							title: item.volumeInfo.title,
							author: item.volumeInfo.authors?.join(", ") || "",
							year: item.volumeInfo.publishedDate?.split("-")[0] || "",
							poster:
								item.volumeInfo.imageLinks?.thumbnail?.replace(
									"http:",
									"https:",
								) || null,
							genre: item.volumeInfo.categories?.join(", ") || "",
						})) || [],
					)
				}
			} catch (e) {
				setResults([])
			}
			setSearching(false)
		}, 400)
	}, [query])

	const selectItem = async (item) => {
		if (isMedia) {
			try {
				const detailEndpoint = isFilm ? `movie/${item.id}` : `tv/${item.id}`
				const creditEndpoint = isFilm
					? `movie/${item.id}/credits`
					: `tv/${item.id}/credits`

				const [details, credits] = await Promise.all([
					fetch(
						`https://api.themoviedb.org/3/${detailEndpoint}?api_key=${TMDB_KEY}&language=fr-FR`,
					).then((r) => r.json()),
					fetch(
						`https://api.themoviedb.org/3/${creditEndpoint}?api_key=${TMDB_KEY}`,
					).then((r) => r.json()),
				])

				if (isFilm) {
					setForm({
						title: item.title,
						director:
							credits.crew?.find((c) => c.job === "Director")?.name || "",
						year: item.release_date?.split("-")[0] || "",
						genre: details.genres?.map((g) => g.name).join(", ") || "",
						actors:
							credits.cast
								?.slice(0, 4)
								.map((a) => a.name)
								.join(", ") || "",
						country: details.production_countries?.[0]?.name || "",
						source: "",
						watched: false,
						poster: item.poster_path ? TMDB_IMG_SM + item.poster_path : "",
					})
				} else {
					setForm({
						title: item.name,
						creator: details.created_by?.[0]?.name || "",
						year: item.first_air_date?.split("-")[0] || "",
						genre: details.genres?.map((g) => g.name).join(", ") || "",
						actors:
							credits.cast
								?.slice(0, 4)
								.map((a) => a.name)
								.join(", ") || "",
						country: details.origin_country?.[0] || "",
						seasons: details.number_of_seasons || "",
						source: "",
						watched: false,
						poster: item.poster_path ? TMDB_IMG_SM + item.poster_path : "",
					})
				}
			} catch (e) {
				setForm({
					...form,
					title: item.title || item.name,
					year: (item.release_date || item.first_air_date)?.split("-")[0] || "",
				})
			}
		} else {
			// Livre ou BD
			setForm({
				title: item.title,
				author: item.author || "",
				year: item.year || "",
				genre: item.genre || "",
				source: "",
				watched: false,
				poster: item.poster || "",
			})
		}
		setMode("manual")
		setResults([])
		setQuery("")
	}

	const handleSubmit = (e) => {
		e.preventDefault()
		if (!form.title) return
		onAdd({
			...form,
			id: Date.now(),
			year: parseInt(form.year) || new Date().getFullYear(),
			seasons: form.seasons ? parseInt(form.seasons) : undefined,
		})
		onClose()
	}

	const getTypeLabel = () => {
		if (isFilm) return "un film"
		if (isSeries) return "une s√©rie"
		if (isBook) return "un livre"
		return "une BD"
	}

	const getIcon = () => {
		if (isFilm) return "üé¨"
		if (isSeries) return "üì∫"
		if (isBook) return "üìö"
		return "üìñ"
	}

	return (
		<div className="modal-bg" onClick={onClose}>
			<div className="modal add-modal" onClick={(e) => e.stopPropagation()}>
				<div className="modal-head">
					<div className="modal-title">Ajouter {getTypeLabel()}</div>
					<button className="modal-close" onClick={onClose}>
						√ó
					</button>
				</div>
				<div className="modal-body">
					{mode === "search" && (
						<>
							<div className="search-input-wrap">
								<input
									type="text"
									className="search-box full"
									placeholder={`Rechercher ${getTypeLabel()}...`}
									value={query}
									onChange={(e) => setQuery(e.target.value)}
									autoFocus
								/>
								{searching && <div className="spinner"></div>}
							</div>

							{results.length > 0 && (
								<div className="search-results">
									{results.map((m) => (
										<div
											key={m.id}
											className="search-result"
											onClick={() => selectItem(m)}
										>
											{(isMedia ? m.poster_path : m.poster) ? (
												<img
													src={isMedia ? TMDB_IMG_SM + m.poster_path : m.poster}
													alt=""
												/>
											) : (
												<div className="no-poster">{getIcon()}</div>
											)}
											<div>
												<div className="result-title">{m.title || m.name}</div>
												<div className="result-year">
													{isMedia
														? (m.release_date || m.first_air_date)?.split(
																"-",
															)[0]
														: m.year}
													{!isMedia && m.author && ` ¬∑ ${m.author}`}
												</div>
											</div>
										</div>
									))}
								</div>
							)}

							<button className="link-btn" onClick={() => setMode("manual")}>
								Ou ajouter manuellement ‚Üí
							</button>
						</>
					)}

					{mode === "manual" && (
						<form onSubmit={handleSubmit}>
							{form.poster && (
								<div className="form-poster">
									<img src={form.poster} alt="" />
									<button
										type="button"
										onClick={() => {
											setForm({ ...form, poster: "" })
											setMode("search")
										}}
									>
										Changer
									</button>
								</div>
							)}

							<div className="form-grid">
								<label className="full">
									<span>Titre *</span>
									<input
										type="text"
										value={form.title}
										onChange={(e) =>
											setForm({ ...form, title: e.target.value })
										}
										required
									/>
								</label>
								<label>
									<span>
										{isFilm ? "R√©alisateur" : isSeries ? "Cr√©ateur" : "Auteur"}
									</span>
									<input
										type="text"
										value={
											isFilm
												? form.director
												: isSeries
													? form.creator
													: form.author
										}
										onChange={(e) =>
											setForm({
												...form,
												[isFilm ? "director" : isSeries ? "creator" : "author"]:
													e.target.value,
											})
										}
									/>
								</label>
								<label>
									<span>Ann√©e</span>
									<input
										type="number"
										value={form.year}
										onChange={(e) => setForm({ ...form, year: e.target.value })}
									/>
								</label>
								{isSeries && (
									<label>
										<span>Saisons</span>
										<input
											type="number"
											value={form.seasons}
											onChange={(e) =>
												setForm({ ...form, seasons: e.target.value })
											}
										/>
									</label>
								)}
								<label className={isSeries ? "" : "full"}>
									<span>Genre</span>
									<input
										type="text"
										value={form.genre}
										onChange={(e) =>
											setForm({ ...form, genre: e.target.value })
										}
										placeholder={isMedia ? "Drame, Action..." : "Roman, SF..."}
									/>
								</label>
								<label className="full">
									<span>Source / Reco</span>
									<input
										type="text"
										value={form.source}
										onChange={(e) =>
											setForm({ ...form, source: e.target.value })
										}
										placeholder="Reco ami..."
									/>
								</label>
								<label className="checkbox">
									<input
										type="checkbox"
										checked={form.watched}
										onChange={(e) =>
											setForm({ ...form, watched: e.target.checked })
										}
									/>
									<span>{isMedia ? "D√©j√† vu" : "D√©j√† lu"}</span>
								</label>
							</div>

							<div className="form-actions">
								<button
									type="button"
									className="btn btn-secondary"
									onClick={onClose}
								>
									Annuler
								</button>
								<button type="submit" className="btn btn-primary">
									Ajouter
								</button>
							</div>
						</form>
					)}
				</div>
			</div>
		</div>
	)
}

// Suggestions Component
const Suggestions = ({ item, type, existingIds, onAdd }) => {
	const [suggestions, setSuggestions] = useState([])
	const [loading, setLoading] = useState(false)

	const isMedia = type === "films" || type === "series"

	useEffect(() => {
		const fetchSuggestions = async () => {
			setLoading(true)
			setSuggestions([])

			try {
				if (isMedia) {
					// TMDB pour films/s√©ries
					const endpoint = type === "films" ? "search/movie" : "search/tv"
					const searchRes = await fetch(
						`https://api.themoviedb.org/3/${endpoint}?api_key=${TMDB_KEY}&query=${encodeURIComponent(item.title)}&year=${item.year}`,
					)
					const searchData = await searchRes.json()

					if (searchData.results?.[0]) {
						const id = searchData.results[0].id
						const recEndpoint =
							type === "films"
								? `movie/${id}/recommendations`
								: `tv/${id}/recommendations`
						const recRes = await fetch(
							`https://api.themoviedb.org/3/${recEndpoint}?api_key=${TMDB_KEY}&language=fr-FR`,
						)
						const recData = await recRes.json()

						const filtered = (recData.results || [])
							.filter(
								(r) =>
									!existingIds.includes(
										(r.title || r.name || "").toLowerCase(),
									),
							)
							.slice(0, 6)
							.map((r) => ({
								id: r.id,
								title: r.title || r.name,
								year: (r.release_date || r.first_air_date)?.split("-")[0],
								poster: r.poster_path ? TMDB_IMG_SM + r.poster_path : null,
								source: "tmdb",
							}))

						setSuggestions(filtered)
					}
				} else {
					// Google Books pour livres/BD
					const searchRes = await fetch(
						`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(item.title + " " + (item.author || ""))}&maxResults=1`,
					)
					const searchData = await searchRes.json()

					if (searchData.items?.[0]) {
						const bookId = searchData.items[0].id

						// Chercher des livres similaires par auteur ou cat√©gorie
						const author =
							item.author || searchData.items[0].volumeInfo?.authors?.[0] || ""
						const category =
							searchData.items[0].volumeInfo?.categories?.[0] || ""

						let query = ""
						if (author) query = `inauthor:${author}`
						else if (category) query = `subject:${category}`
						else query = item.title.split(" ")[0] // Premier mot du titre

						const recRes = await fetch(
							`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(query)}&maxResults=12&langRestrict=fr`,
						)
						const recData = await recRes.json()

						const filtered = (recData.items || [])
							.filter((r) => {
								const title = r.volumeInfo?.title || ""
								return (
									title.toLowerCase() !== item.title.toLowerCase() &&
									!existingIds.includes(title.toLowerCase())
								)
							})
							.slice(0, 6)
							.map((r) => ({
								id: r.id,
								title: r.volumeInfo?.title || "",
								year: r.volumeInfo?.publishedDate?.split("-")[0] || "",
								poster:
									r.volumeInfo?.imageLinks?.thumbnail?.replace(
										"http:",
										"https:",
									) || null,
								author: r.volumeInfo?.authors?.[0] || "",
								source: "google",
							}))

						setSuggestions(filtered)
					}
				}
			} catch (e) {
				console.error("Erreur suggestions:", e)
			}
			setLoading(false)
		}

		if (item?.title) {
			fetchSuggestions()
		}
	}, [item?.id])

	const addSuggestion = async (sug) => {
		try {
			if (sug.source === "tmdb") {
				// Ajout film/s√©rie depuis TMDB
				const endpoint = type === "films" ? `movie/${sug.id}` : `tv/${sug.id}`
				const creditEndpoint =
					type === "films" ? `movie/${sug.id}/credits` : `tv/${sug.id}/credits`

				const [details, credits] = await Promise.all([
					fetch(
						`https://api.themoviedb.org/3/${endpoint}?api_key=${TMDB_KEY}&language=fr-FR`,
					).then((r) => r.json()),
					fetch(
						`https://api.themoviedb.org/3/${creditEndpoint}?api_key=${TMDB_KEY}`,
					).then((r) => r.json()),
				])

				const newItem = {
					id: Date.now(),
					title: sug.title,
					year: parseInt(sug.year) || 0,
					poster: sug.poster,
					genre: details.genres?.map((g) => g.name).join(", ") || "",
					watched: false,
				}

				if (type === "films") {
					newItem.director =
						credits.crew?.find((c) => c.job === "Director")?.name || ""
					newItem.actors =
						credits.cast
							?.slice(0, 4)
							.map((a) => a.name)
							.join(", ") || ""
					newItem.country = details.production_countries?.[0]?.name || ""
				} else {
					newItem.creator = details.created_by?.[0]?.name || ""
					newItem.actors =
						credits.cast
							?.slice(0, 4)
							.map((a) => a.name)
							.join(", ") || ""
					newItem.seasons = details.number_of_seasons || 0
				}

				onAdd(newItem)
			} else {
				// Ajout livre/BD depuis Google Books
				const res = await fetch(
					`https://www.googleapis.com/books/v1/volumes/${sug.id}`,
				)
				const data = await res.json()
				const info = data.volumeInfo || {}

				const newItem = {
					id: Date.now(),
					title: info.title || sug.title,
					author: info.authors?.join(", ") || "",
					year: parseInt(info.publishedDate?.split("-")[0]) || 0,
					genre: info.categories?.join(", ") || "",
					poster:
						info.imageLinks?.thumbnail?.replace("http:", "https:") ||
						sug.poster,
					watched: false,
				}

				onAdd(newItem)
			}

			setSuggestions(suggestions.filter((s) => s.id !== sug.id))
		} catch (e) {
			console.error("Erreur ajout suggestion:", e)
		}
	}

	if (loading) {
		return (
			<div className="suggestions">
				<div className="suggestions-title">Suggestions</div>
				<div className="suggestions-loading">Chargement...</div>
			</div>
		)
	}

	if (suggestions.length === 0) return null

	return (
		<div className="suggestions">
			<div className="suggestions-title">
				{isMedia
					? "Si vous avez aim√©, vous aimerez peut-√™tre..."
					: `Du m√™me auteur ou genre...`}
			</div>
			<div className="suggestions-grid">
				{suggestions.map((sug) => (
					<div
						key={sug.id}
						className="suggestion-card"
						onClick={() => addSuggestion(sug)}
					>
						{sug.poster ? (
							<img src={sug.poster} alt={sug.title} />
						) : (
							<div className="suggestion-noimg">?</div>
						)}
						<div className="suggestion-info">
							<div className="suggestion-title">{sug.title}</div>
							<div className="suggestion-year">{sug.author || sug.year}</div>
						</div>
						<div className="suggestion-add">+</div>
					</div>
				))}
			</div>
		</div>
	)
}

// Edit Modal
const EditModal = ({ item, type, onClose, onSave }) => {
	const isFilm = type === "films"
	const isSeries = type === "series"
	const isMedia = isFilm || isSeries

	const [form, setForm] = useState({
		title: item.title || "",
		director: item.director || "",
		creator: item.creator || "",
		author: item.author || "",
		year: item.year || "",
		genre: item.genre || "",
		actors: item.actors || "",
		country: item.country || "",
		source: item.source || "",
		seasons: item.seasons || "",
		watched: item.watched || false,
		rating: item.rating || 0,
	})

	const handleSubmit = (e) => {
		e.preventDefault()
		if (!form.title) return
		onSave(item.id, {
			...form,
			year: parseInt(form.year) || item.year,
			seasons: form.seasons ? parseInt(form.seasons) : undefined,
			rating: form.rating || undefined,
		})
	}

	return (
		<div className="modal-bg" onClick={onClose}>
			<div className="modal add-modal" onClick={(e) => e.stopPropagation()}>
				<div className="modal-head">
					<div className="modal-title">Modifier</div>
					<button className="modal-close" onClick={onClose}>
						√ó
					</button>
				</div>
				<div className="modal-body">
					<form onSubmit={handleSubmit}>
						<div className="form-grid">
							<label className="full">
								<span>Titre *</span>
								<input
									type="text"
									value={form.title}
									onChange={(e) => setForm({ ...form, title: e.target.value })}
									required
								/>
							</label>
							<label>
								<span>
									{isFilm ? "R√©alisateur" : isSeries ? "Cr√©ateur" : "Auteur"}
								</span>
								<input
									type="text"
									value={
										isFilm
											? form.director
											: isSeries
												? form.creator
												: form.author
									}
									onChange={(e) =>
										setForm({
											...form,
											[isFilm ? "director" : isSeries ? "creator" : "author"]:
												e.target.value,
										})
									}
								/>
							</label>
							<label>
								<span>Ann√©e</span>
								<input
									type="number"
									value={form.year}
									onChange={(e) => setForm({ ...form, year: e.target.value })}
								/>
							</label>
							{isSeries && (
								<label>
									<span>Saisons</span>
									<input
										type="number"
										value={form.seasons}
										onChange={(e) =>
											setForm({ ...form, seasons: e.target.value })
										}
									/>
								</label>
							)}
							<label className={isSeries ? "" : "full"}>
								<span>Genre</span>
								<input
									type="text"
									value={form.genre}
									onChange={(e) => setForm({ ...form, genre: e.target.value })}
									placeholder={isMedia ? "Drame, Action..." : "Roman, SF..."}
								/>
							</label>
							{isMedia && (
								<label className="full">
									<span>Casting</span>
									<input
										type="text"
										value={form.actors}
										onChange={(e) =>
											setForm({ ...form, actors: e.target.value })
										}
									/>
								</label>
							)}
							<label className="full">
								<span>Source / Reco</span>
								<input
									type="text"
									value={form.source}
									onChange={(e) => setForm({ ...form, source: e.target.value })}
									placeholder="Reco ami..."
								/>
							</label>
							<label className="checkbox">
								<input
									type="checkbox"
									checked={form.watched}
									onChange={(e) =>
										setForm({ ...form, watched: e.target.checked })
									}
								/>
								<span>{isMedia ? "Vu" : "Lu"}</span>
							</label>
							{form.watched && (
								<label>
									<span>Note</span>
									<div className="rating-input">
										{[1, 2, 3, 4, 5].map((n) => (
											<span
												key={n}
												className={`star ${form.rating >= n ? "active" : ""}`}
												onClick={() =>
													setForm({
														...form,
														rating: form.rating === n ? 0 : n,
													})
												}
											>
												‚òÖ
											</span>
										))}
									</div>
								</label>
							)}
						</div>

						<div className="form-actions">
							<button
								type="button"
								className="btn btn-secondary"
								onClick={onClose}
							>
								Annuler
							</button>
							<button type="submit" className="btn btn-primary">
								Enregistrer
							</button>
						</div>
					</form>
				</div>
			</div>
		</div>
	)
}

export default App
